이코테 요약 정리된 곳
https://freedeveloper.tistory.com/271

global 사용법
https://sikaleo.tistory.com/99

순열, 조합 구현
https://shoark7.github.io/programming/algorithm/Permutations-and-Combinations


정수인지 확인 
- if int(x) == x: 

가장 큰, 작은 값 구하기 
- 리스트에 값들 다 넣고 max, min 사용
- 예시 
    xs = [p[0] for p in points]
    x_min = min(xs)
    x_max = max(xs)

6/27
다리를 지나는 트럭
- 문제를 잘못 이해해서 틀림
- 문제를 정확하게 파악하고 풀자

우박수열 정적분
- 주석으로 파악하기 쉽게 구분해놓고 풀자

6/30
롤케이크 자르기
- 처음에 빅오 생각
- 시간초과 발생할 경우 바뀌는 것만 집중적으로 축소시키자
- 예시
    어디서 자르는 지만 바뀐다. -> 자르는 곳 원소 하나만으로 해결

2 x n 타일링
- 문제에서 1000000007으로 나눈 나머지를 return해달라고 
  했는데 문제 제대로 안읽음
- 이전 과정과 관련돼서 해결함

7/1
방문 길이
- 2차원 배열로 풀어서 복잡해서 실수하고 오타나서 오래걸림
- 오타 확인하자

프로세스
- 문제를 제대로 안읽음
- 문제를 정확하게 파악하자

7/3
셔틀버스
- 리스트에서 값에대한 인덱스 구하는 법 (중복일 경우 처음 인덱스 출력)
  arr.index(value)
- 리스트 중복된 값에 대한 마지막 인덱스 구하는 법
  reverse를 통해 뒤집고 index()로 처음 인덱스 구하고 len값을 통해 마지막 인덱스 구함
- 리스트 얇은 복사
  copy_arr = arr[:]
- 먼저 문제를 파악하고 해를 구하는 논리를 구하고 구현하자

7/4
풍선 터트리기
- 문제 파악하고 해를 구하는 논리는 쉬웠음
- 근데 시간초과를 피하면서 왼쪽, 오른쪽 가장 작은 값 구하는게 어려움
- 해결 방법
  먼저 i일 때 i만 바뀌는거에 집중하고 왼쪽, 오른쪽 가장 작은 값을 구하는데 
  오른쪽도 -i로 동시에 가장 작은 값들을 구해놓고 이 값들을 통해 해를 구함

7/5
스타 수열
- 문제 파악하고 간단하게 해를 구하는 논리 찾는데 실패함 (간단하게 안하면 시간초과 발생할거 같았음)
- 실패했으면 문제 그대로 따라가는 방법으로 풀자
- conter 사용법 익힘
  from collections import Counter
  els = Counter(a)
  for k in els.keys():

7/10
합승 택시 요금
- 다익스트라, 플로이드와샬 
- heapq사용법
- 제출시 오류 한두개 발생한 경우 최대값 설정 확인, 이 문제에서 왜 최대값 오류 발생했는지는 모르겠음

7/19
110 옮기기
- 문자열은 인덱스로 변경 안됨 -> 리스트로 바꾸고 변경, 값으로 변경은 가능(remove)
- heapq사용법
- for s in stack[::-1]
- 문제를 그대로 풀었는데 예외 발생하고 시간초과가 발생함 -> 스택으로 110 개수 찾고 110을 문자열에서 다 뺴면 두개 이산 연속인 1이 최대 한곳 존재
  연속된 1 앞에 110 개수만큼 넣어서 해결
- 사전 관련된 문제인 경우 이 방법 고려
- 어떻게 이런 생각을 하는지 모르겠음

7/20
- 문제 이해를 잘 못하고 생각이 안남
- 일단 이진수로 변환 bin(num)
- 포화이진트리로 만들기 위해 2**n - 1로 가장 작은 길이 구함
- 재귀를 통해 루트노드를 탐색하면서 부모노드가 더미노드 자식노드가 더미노드 아닌 경우를 찾음
- 포화이진트리 특성 활용, 트리의 특성 활용, 재귀

7/21
- 동적계획법 문제
1) DP로 풀 수 있는 문제인지 확인한다.
2) 문제의 변수 파악
3) 변수 간 관계식 만들기(점화식)
4) 메모하기(memoization or tabulation)
5) 기저 상태 파악하기
6) 구현하기
- 참고 사이트
https://hongjw1938.tistory.com/47
