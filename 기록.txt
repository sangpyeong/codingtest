이코테 요약 정리된 곳
https://freedeveloper.tistory.com/271

global 사용법
https://sikaleo.tistory.com/99

순열, 조합 구현
https://shoark7.github.io/programming/algorithm/Permutations-and-Combinations


정수인지 확인 
- if int(x) == x: 

가장 큰, 작은 값 구하기 
- 리스트에 값들 다 넣고 max, min 사용
- 예시 
    xs = [p[0] for p in points]
    x_min = min(xs)
    x_max = max(xs)

6/27
다리를 지나는 트럭
- 문제를 잘못 이해해서 틀림
- 문제를 정확하게 파악하고 풀자

우박수열 정적분
- 주석으로 파악하기 쉽게 구분해놓고 풀자

6/30
롤케이크 자르기
- 처음에 빅오 생각
- 시간초과 발생할 경우 바뀌는 것만 집중적으로 축소시키자
- 예시
    어디서 자르는 지만 바뀐다. -> 자르는 곳 원소 하나만으로 해결

2 x n 타일링
- 문제에서 1000000007으로 나눈 나머지를 return해달라고 
  했는데 문제 제대로 안읽음
- 이전 과정과 관련돼서 해결함

7/1
방문 길이
- 2차원 배열로 풀어서 복잡해서 실수하고 오타나서 오래걸림
- 오타 확인하자

프로세스
- 문제를 제대로 안읽음
- 문제를 정확하게 파악하자

7/3
셔틀버스
- 리스트에서 값에대한 인덱스 구하는 법 (중복일 경우 처음 인덱스 출력)
  arr.index(value)
- 리스트 중복된 값에 대한 마지막 인덱스 구하는 법
  reverse를 통해 뒤집고 index()로 처음 인덱스 구하고 len값을 통해 마지막 인덱스 구함
- 리스트 얇은 복사
  copy_arr = arr[:]
- 먼저 문제를 파악하고 해를 구하는 논리를 구하고 구현하자

풍선 터트리기
- 문제 파악하고 해를 구하는 논리는 쉬웠음
- 근데 시간초과를 피하면서 왼쪽, 오른쪽 가장 작은 값 구하는게 어려움
- 해결 방법
  먼저 i일 때 i만 바뀌는거에 집중하고 왼쪽, 오른쪽 가장 작은 값을 구하는데 
  오른쪽도 -i로 동시에 가장 작은 값들을 구해놓고 이 값들을 통해 해를 구함
