이코테 요약 정리된 곳
https://freedeveloper.tistory.com/271

global 사용법
https://sikaleo.tistory.com/99

순열, 조합 구현
https://shoark7.github.io/programming/algorithm/Permutations-and-Combinations


정수인지 확인 
- if int(x) == x: 

가장 큰, 작은 값 구하기 
- 리스트에 값들 다 넣고 max, min 사용
- 예시 
    xs = [p[0] for p in points]
    x_min = min(xs)
    x_max = max(xs)

6/27
다리를 지나는 트럭
- 문제를 잘못 이해해서 틀림
- 문제를 정확하게 파악하고 풀자

우박수열 정적분
- 주석으로 파악하기 쉽게 구분해놓고 풀자

6/30
롤케이크 자르기
- 처음에 빅오 생각
- 시간초과 발생할 경우 바뀌는 것만 집중적으로 축소시키자
- 예시
    어디서 자르는 지만 바뀐다. -> 자르는 곳 원소 하나만으로 해결

2 x n 타일링
- 문제에서 1000000007으로 나눈 나머지를 return해달라고 
  했는데 문제 제대로 안읽음
- 이전 과정과 관련돼서 해결함

7/1
방문 길이
- 2차원 배열로 풀어서 복잡해서 실수하고 오타나서 오래걸림
- 오타 확인하자

프로세스
- 문제를 제대로 안읽음
- 문제를 정확하게 파악하자

7/3
셔틀버스
- 리스트에서 값에대한 인덱스 구하는 법 (중복일 경우 처음 인덱스 출력)
  arr.index(value)
- 리스트 중복된 값에 대한 마지막 인덱스 구하는 법
  reverse를 통해 뒤집고 index()로 처음 인덱스 구하고 len값을 통해 마지막 인덱스 구함
- 리스트 얇은 복사
  copy_arr = arr[:]
- 먼저 문제를 파악하고 해를 구하는 논리를 구하고 구현하자

7/4
풍선 터트리기
- 문제 파악하고 해를 구하는 논리는 쉬웠음
- 근데 시간초과를 피하면서 왼쪽, 오른쪽 가장 작은 값 구하는게 어려움
- 해결 방법
  먼저 i일 때 i만 바뀌는거에 집중하고 왼쪽, 오른쪽 가장 작은 값을 구하는데 
  오른쪽도 -i로 동시에 가장 작은 값들을 구해놓고 이 값들을 통해 해를 구함

7/5
스타 수열
- 문제 파악하고 간단하게 해를 구하는 논리 찾는데 실패함 (간단하게 안하면 시간초과 발생할거 같았음)
- 실패했으면 문제 그대로 따라가는 방법으로 풀자
- conter 사용법 익힘
  from collections import Counter
  els = Counter(a)
  for k in els.keys():

7/10
합승 택시 요금
- 다익스트라, 플로이드와샬 
- heapq사용법
- 제출시 오류 한두개 발생한 경우 최대값 설정 확인, 이 문제에서 왜 최대값 오류 발생했는지는 모르겠음

7/19
110 옮기기
- 문자열은 인덱스로 변경 안됨 -> 리스트로 바꾸고 변경, 값으로 변경은 가능(remove)
- heapq사용법
- for s in stack[::-1]
- 문제를 그대로 풀었는데 예외 발생하고 시간초과가 발생함 -> 스택으로 110 개수 찾고 110을 문자열에서 다 뺴면 두개 이산 연속인 1이 최대 한곳 존재
  연속된 1 앞에 110 개수만큼 넣어서 해결
- 사전 관련된 문제인 경우 이 방법 고려
- 어떻게 이런 생각을 하는지 모르겠음

7/20
- 문제 이해를 잘 못하고 생각이 안남
- 일단 이진수로 변환 bin(num)
- 포화이진트리로 만들기 위해 2**n - 1로 가장 작은 길이 구함
- 재귀를 통해 루트노드를 탐색하면서 부모노드가 더미노드 자식노드가 더미노드 아닌 경우를 찾음
- 포화이진트리 특성 활용, 트리의 특성 활용, 재귀

7/21
- 동적계획법 문제
1) DP로 풀 수 있는 문제인지 확인한다.
2) 문제의 변수 파악
3) 변수 간 관계식 만들기(점화식)
4) 메모하기(memoization or tabulation)
5) 기저 상태 파악하기
6) 구현하기
- 참고 사이트
https://hongjw1938.tistory.com/47

7/23 
디스크 컨트롤러(o)
- 처음에 시간을 0초부터 1씩 증가하려다가 시간초과 발생할거 같아서 jobs의 인덱스를 기준으로 하였다.
- heapq사용함
- 예외 경우인 특정 작업을 끝냈는데 힙큐에 작업이 없는 경우 처리해야함

7/25
블록 이동하기(x)
- MAX = float('inf') 양의 무한대를 의미함
- visited = set() 방문한 것은 set으로 표시하는게 좋음
- if not -1 < ax < N or not -1 < ay < N or board[ay][ax] == 1: not을 이용해서 조건식을 줄일 수 있음
- for i in [-1, 1] : 반복문을 원하는 리스트를 넣어 실행할 수 있음
- [:]이거도 얕은 복사임 https://blockdmask.tistory.com/576
- 전역변수를 수정할 때는 global 필요 https://www.infoking.site/64
- 풀이 방법: bfs 활용, 회전을 처리하는 방법

리코쳇 로봇
- while 0 <= nx < len(board[0]) and 0 <= ny < len(board) and board[ny][nx] != 'D':
    nx, ny = nx + dx[i], ny + dy[i]
  while로 끝까지 미끄러지는 코드를 작성해 간단하게 함
-   if board[y][x] == 'G':
            answer = t
            return answer
  여기서 return 을 안해서 오류가 발생했었음 -> 코드를 자세하게 처음부터 검토하자
- 풀이 방법: bfs활용, 끝까지 미끄러지는 방법

7/26
n진수 게임
- 문자열은 +로 추가함
- //, %, divmod() 연산
- extend(arr) 리스트에 다른 리스트 요소들 추가
- NUMBERS = "0123456789ABCDEF" 를 통해 더 간단하게 가능
- res[::-1] 리버스와 기능 같음

삼각 달팽이
- arr.insert() 리스트 인덱스에 추가
- 2차원 배열 만드는 법
- 다른 풀이는 2차원 배열의 좌표를 통해 간단하게 구현함

7/31
풍선 터트리기 복습

고고학 최고의 발견
- dp로 풀긴 했는데 시간초과 발생함
- 답을 봐도 굉장히 어려움 
- 아직 완변한 이해x, 윗줄부터 다음줄까지 0을 만들면서 내려가서 해결하는 방식

8/2
연습 경로
- dfs문제, 그래프를 굳이 만들 필요없이 백트래킹 함께 사용함
- 언팩 기능: dfs([*path, end]) *
- enumerate 기능: for i, [start, end] in enumerate(tickets):
- 백트래킹 재귀 함수: 종결 부분, 반복문, 조건(방문여부, 조건), 재귀 
  for i, [start, end] in enumerate(tickets):
    if ch[i] == 0 and path[-1] == start:
      ch[i] = 1
      dfs([*path, end])
      ch[i] = 0

코딩테스트 공부
- dp문제, 2차원 배열로 최소 시간을 기록하면서 해를 구함
- deque를 사용하는 dp방식으로 하면 복잡함
- 예외경우 처리) 처음 능력이 목표 능력보다 높은 경우

8/3
양과 늑대
- 진짜 너무 멍청해서 화가 난다
- 일단 bfs와 dfs 생각이 나긴 함 그래서 bfs를 하려고 했는데 실패함, 하다보니까 dfs를 써야겟다고 생각은 했는데 감이 안옴
- dfs 까지 떠오르는 거 까지 ㅇㅋ 그 다음 dfs 정석 dfs함수 -> 종결 조건, 반복문 조건 visited 1 재귀 0 을 기억하고 풀어보자 제발

9/20
노션에 기록하다가 여기에 기록하는게 찾기 쉬울 거 같아서 여기에 다시 기록하기로 함

불량 사용자
- 순열 or 백트래킹 문제
- 내가 푼 풀이는 벤 아이디 한 개에서 가능한 아이디들 목록을 구해서 목록들의 조합을 구해서 풀려고 했는데 목록중에 겹치는게 있는 경우 예외 처리를 해야함 그래서 전부 다 구하고 중복되는거 뺴서 구할려고 했는데 실패함
- chat gpt가 푸는 거 보니까 백트래킹 사용함 나도 시도하다가 실패했는데 used 사용해서 함
- 알고리즘:
  가능한 아이디 목록 구하고 
  백트래킹으로 인덱스를 인자로 받으면서 진행
  used를 통해 중복 포함 전부 구하는 것이 아니라 원소 중복은 빼고 구함
  종결 조건에서는 순서 상관 없이 구하기 위해 set 활용
- 다른 사람 풀이 알고리즘:
  처음부터 밴 아이디 개수만큼 순열을 permutations를 import 해서 구하고 
  조건에 맞는 것만 모아서 개수를 구해 정답을 구함
- 알게된 문법:
  from itertools import permutations
  dic = {}
  set = set()
  set에는 set을 넣을 수 없음
  같은 값들이 들어 있는 set은 ==연산시 True
  따라서 permutations에서 중복된 것들을 set을 가지고 있는 list를 통해 not in 연산으로 중복 제거 할 수 있음

최적의 행렬 곱셈
- dp문제
- 처음 풀 때는 모든 가능한 순서를 백 트래킹으로 구하고 가장 큰 값부터 연산해서 값을 구하려고 했는데 우선 백 트래킹이 시간 초과하는 문제와 큰 값부터 연산할 때 맨 앞, 맨 뒤 값은 빼야 하는데 이 값이 중복인 경우 처리 방법 등 자세하게 들어가면 예외의 경우 때문에 어려운 것을 알게 됨
- chat gpt 풀이 보니까 그냥 문제 설명이 빈약함 문제에서 matrix_sizes의 순서대로만 하라고 추가 설명이 존재하지 않아 matrix_sizes말고 다른 연산 순서로 풀이함
- chat gpt 알고리즘
  dp 테이블 2차원 리스트로 i부터 j까지 연산을 기준으로 설정
  반복문으로 i와 j, gap을 만들고 dp[i][j] 무한대 값으로 초기화
  i와 j 사이값인 k를 반복문으로 만들고 [i][k] + [k+1][j] + 연산값을 구하고 이전 dp 값과 비교해서 작은 값을 넣어 dp 수정하면서 답 구함
- 알게된 문법:
  float('inf')


문제 풀면서 느낀점:
  먼저 그리디, 브루트포스, dp 등 다양한 방법들을 생각해서 가능한지 확인 (시간, 알고리즘)
  가능한거 같으면 그 방법으로 진행하다가 자세히 들어가니까 예외 경우가 발생해 힘들거 같으면 다른 방법 시도
  너무 복잡해진다 싶으면 다른 방법으로 바꿔야 함(시간을 정해놓고 넘어가면 바꾸기)

9/23
[3차] 자동완성
- trie 자료구조 문제
- 내가 푼 풀이는 dict 자료구조를 통해 구현했지만 시간 초과가 발생해서 실패함
- 다른 풀이는 trie 자료구조 사용, trie 자료구조는 문자열을 저장하고 검색하는데 효율적인 자료구조
- 알게된 문법:
  class Trie() 자료구조 생성, 활용 법
  함수에서 self를 사용하는 방법 
  enumerate의 변수는 for문 밖에서도 사용할 수 있음?
  __init__함수, __str__함수 사용법

  9/25
  [1차] 추석 트래픽
  - 시간 처리 문제
  - 내가 푼 풀이는 일단 시간을 어떻게 처리할지 몰라서 실패하고 힙을 사용할려고 했는데 굳이 필요 없다는 것을 다른 풀이를 보며 깨달음
  - 다른 풀이:
    시간을 시간 처리를 시에는 3600을 곱하고 분에는 60 시는 그대로 하고 밀리초를 위해 전부 1000을 곱해서 처리
    시간 처리를통해 시작 시간을 쉽게 구할 수 있었고 lines는 오름차순으로 정렬되어 있기 때문에 힙이 필요없고 반복문으로 카운팅만 하면 정답 구함
  - 알게 된 것:
    시간 처리를 하는법
    오름차순으로 되어 있어서 힙이 필요 없음
    
  9/28
  단속카메라
  - 그리디 문제
  - 처음에는 -30000에서 30000까지 루트에 1씩 더해서 감소되는 부분에 카메라를 넣어서 하려고 했지만 예외 발생해서 다른방법 시도
  - dp, 이분탐색 등 다른 방법 생각은 해봤는데 안됨
  - 문제 카테고리가 그리디인거 확인하고 그리디 방법 생각하다가 routes중에 마지막 값으로 정렬하고 마지막 값에만 카메라 설치하면 되는것을 알게 됨
  - 알고리즘:
    뒤에 값으로 정렬
    반복문으로 뒤에값을 카메라 설치하고 구간에 있으면 continue 없으면 추가해서 nums를 채워 정답을 구함 
  - 알게 된 것:
    파이썬에서 조건으로 정렬하는 법
    인덱스 -1로 마지막 값을 얻는 법

10/2
올바른 괄호의 갯수
- 백트래킹 문제, dp문제
- 나는 백트래킹으로 풀었는데 검색해보니까 카탈란 수열? 을 써서 푼 경우가 많음 근데 이걸로 푼건 말 안됨
- 내 알고리즘:
  백트래킹에서 종결 조건을 만들고 여는 괄호가 n보다 작은 경우 여는 괄호 넣고 o를 1증가
  o가 c보다 크다면 닫는 괄호 넣어도 돼서 넣고 백트래킹
- 근데 기존 내가 썻었던 백트래킹은 반복문이 있었는데 이번에 넣을려고 했지만 필요성을 못느껴 빼서 구현
- 알게 된 것:
  백트래킹안에 반복문은 필수가 아님 
  카탈란 수열

10/9
사라지는 발판
- dfs문제
- 나는 처음에 dp로 풀려고 했는데 풀다보니 bfs로 풀고 있었고 bfs로 구하는 방법은 예외의 경우가 생겨서 실패
- 답 보니까 dfs로 풀고 함수들을 사용해서 간단하게 풀음
- 알고리즘:
  일단 dfs를 써서 게임이 끝나는 경우를 찾음 
  위 경우에서 전 턴에서 자기가 이기는지 지는지 찾고 이긴다면 최소 턴을 반환 진다면 최대 턴을 반환함 
  이거를 반복해서 답을 구함
- 솔직히 이해가 잘 안됨, 재귀가 진짜 어려운거 같음 재귀 문제를 많이 풀어서 재귀를 통해 푸는 방법을 익혀야함

10/10
보석 쇼핑
- 투 포인터 문제
- 처음에는 set을 통해 처음부터 보석이 다 채워질 때까지 확인해서 해를 구했는데 시간초과가 발생함
- 다른 풀이를 보니까 처음과 끝 두개 포인터를 통해 끝 부분만 변경해서 시간단축을 함
- 알고리즘:
  dic과 start, end를 초기화
  while문을 통해 두 포인터가 범위를 벗어날 때까지 진행
  보석종류 개수가 안채워져 있으면 end 증가
  다 채워져 있으면 start 증가
  각 포인트 변경시 dic 수정해서 정답을 구함
- 알게 된 것:
  시간초과가 발생할 거 같다 -> 변경하는 부분을 최소화

카드 짝 맞추기
- 구현 문제
- 내가 푼 풀이는 현재 위치에서 거리들을 다 구하고 가장 가까운 인형 위치까지 거리 구하고 쌍 지우는 방식으로 진행했지만 a1->a2 와 a2->a1이 횟수가 다른 예외 경우 발생해서 실패함
- 다른 풀이는 순열로 모든 순서 구하고 bfs를 통해 거리 구하고 a1과 a2 역순까지 구해서 구함
- 알게 된 것:
  우선 예외 경우를 처음에 생각하거나 코드가 복잡해지는 것을 방지하기 위해 처음에 어느정도 설계를 해야함
  클린코딩 하는 법을 익혀야함
  함수 활용하는 거 연습하자
  
10/11
복습 휴식

10/12
순위
- 플로이드와샬 문제
- 처음에는 dic이나 트리, 링크드리스트같은 자료구조로 풀려고 했으나 실패함
- 다른 풀이 보니까 플로이드와샬로 2차원 배열을 채우면서 구함
- 알고리즘:
  2차원 배열 초기화하고 이기면 1 지면 -1 저장
  3개 반복문으로 i, j, k 관계 정립(k는 i와 j사이값)
  2차원 배열에서 반복문으로 count(0)함수를 통해 0값 개수를 구하고 1인 경우 answer증가시켜서 정답 구함
- 알게 된 것:
  플루이드와샬 알고리즘
  모든 정점 쌍 간의 관계나 거리를 찾아야 할 때 플루이드와샬 사용 고려해보자

